import asyncio
import json
import os

from pathlib import Path
from grpclib.utils import graceful_exit
from grpclib.server import Server, Stream
from grpclib.exceptions import GRPCError
from grpclib.const import Status

# generated by protoc
from docker_pb2 import CrashAnalyzeRequest, CrashAnalyzeResponse
from docker_grpc import ProcessBase

from clusterfuzz._internal.crash_analysis.crash_result import CrashResult

class Processor(ProcessBase):
    def __init__(self, env, config):
        self.env = env
        self.config = config

    async def AnalyzeCrash(self, stream: Stream[CrashAnalyzeRequest, CrashAnalyzeResponse]) -> None:
        request = await stream.recv_message()
        assert request is not None

        test_bin = self.config.has_section("LAUNCH") and self.config["LAUNCH"].get("SAP_TEST_BIN") or "target"
        binary_path = Path("{}/{}".format(self.env["fuzz_dir"], test_bin))
        if not binary_path.exists():
            raise GRPCError(Status.INVALID_ARGUMENT, "Target binary {} is not found".format(binary_path))

        crash_path = Path("/work/crashes").joinpath(request.name)
        if not crash_path.exists():
            raise GRPCError(Status.INVALID_ARGUMENT, "Requested crash {} is not found".format(crash_path))

        data = crash_path.read_bytes()
        cmd = "{}".format(binary_path)

        proc = await asyncio.create_subprocess_shell(cmd, stdin = asyncio.subprocess.PIPE, stdout = asyncio.subprocess.PIPE, stderr = asyncio.subprocess.STDOUT, env = dict(self.config["ENV"].items()), shell = True, cwd = self.env["fuzz_dir"])
        stdout, _ = await proc.communicate(data)

        cr = CrashResult(proc.returncode, 0, stdout)
        result = {
            'clusterfuzz': {
                'type': cr.get_type(),
                'is_crash': cr.is_crash(),
                'is_security_issue': cr.is_security_issue(),
                'should_ignore': cr.should_ignore(),
                'stacktrace': cr.get_stacktrace(),
                'output': cr.output,
                'return_code': cr.return_code
            }
        }

        await stream.send_message(CrashAnalyzeResponse(result=json.dumps(result)))
